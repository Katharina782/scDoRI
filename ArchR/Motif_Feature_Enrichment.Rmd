---
title: "Motif & Feature Enrichment"
output: 
  html_document:
    toc: true
    toc_depth: 5
    code_folding: hide
    toc_float: true
    code_download: true
    theme: cosmo
    highlight: textmate
---

<style>
body {
text-align: justify}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = TRUE, autodep = TRUE, 
                      collapse = TRUE, message = FALSE)
knitr::opts_knit$set(root.dir = "/omics/groups/OE0533/internal/katharina/scDoRI/ArchR")
setwd("/omics/groups/OE0533/internal/katharina/scDoRI/ArchR/")

set.seed(1)
```

# Load Libraries & ArchR object

```{r}
library(ArchR)
library(rhdf5)
library(reticulate)
library(tidyverse)
#library(caret)
h5disableFileLocking()

# load ArchR project
proj <- loadArchRProject(path = "Save_Vignette_object_3/")

# for R to find macs2 we will use a conda environment where the latest version 
# of macs2 is installed
#conda_list()[[1]][2] %>% use_condaenv(required = TRUE)

```


# Motif and Feature Enrichment

We have identified robust peak sets and now we want to know which TFs bind to
the peak region and thereby create an accessible region. Are the marker peaks 
enriched for binding sites of specific TFs? For example, a lineage-defining TF
will often be enriched in cell-type specific peaks. We might also want to know 
if a cell type-specific peak is enriched for CHIP-seq peaks or other features. 

## Motif Enrichment in Differential Peaks

We will first add the motif annotations to the ArchRProject. We create a binary 
matrix, where the presence or absence of a motif in a peak is indicated. Using
the list of differential peaks more accessible in "Erythroid" than in "Progenitor" cells,
we can define the peaks we want to test for motif enrichment. Using the
`peakAnnoEnrichment()` function we test for enrichment. 

A **hypergeometric test** is used to test the probability of observing the motif
at the given frequency by chance, comparing with a background set of peaks matched 
for GC content.



```{r}
# add motif annotations
# this function requires the ChromVar package
proj <- addMotifAnnotations(ArchRProj = proj,
                            motifSet = "cisbp",
                            name = "Motif")

# get markers between erythroid and progenitor cells
markerTest <- getMarkerFeatures(
  ArchRProj = proj,
  useMatrix = "PeakMatrix",
  groupBy = "Clusters2",
  testMethod = "wilcoxon",
  bias = c("TSSEnrichment", "log10(nFrags)"),
  useGroups = "Erythroid",
  bgdGroups = "Progenitor"
)

# test for motif enrichment
motifsUp <- peakAnnoEnrichment(
  seMarker = markerTest,
  ArchRProj = proj
)

motifsUp
```

For plotting the motifs we create a dataframe containing the motifs, p-values and
the significance rank. In the dataframe we can see that the most motifs enriched 
in the accessbile peaks are GATA transcription factors which is a TF very 
important for erythroid differentiation.

```{r, results = "asis"}
df <- data.frame(TF = rownames(motifsUp), mlog10Padj = assay(motifsUp)[,1])

df <- df %>% arrange(desc(mlog10Padj))
# create a sequenc of desired length for the rank of each TF motif
df$rank <- seq_len(nrow(df)) 
df %>% head %>% knitr::kable()
```

In the plot below the TF motifs are sorted by rank and colored by significance 
of their enrichment. 

```{r}
ggUp <- ggplot(df, aes(rank, mlog10Padj, color = mlog10Padj)) +
  geom_point(size = 1) +
  ggrepel::geom_label_repel(
    data = df[rev(seq_len(30)), ], aes (x = rank, y = mlog10Padj, label = TF),
    size = 1.5, nudge_x = 2,
    color = "black",
    max.overlaps = 30
  ) +
  theme_ArchR() +
  ylab("-log10(P-adj) Motif Enrichment") +
  xlab("Rank sorted TFs enrichment") +
  scale_color_gradientn(colors = paletteContinuous(set = "comet")) +
  labs(title = "Motifs enriched in peaks more accessible in Eryhtroid cells")
ggUp
```

The same plot can be crated for motifs enriched in progenitor cells. For this we
use peaks with `Log2FC <= 0.5`. 
```{r, results = "asis"}
motifsDo <- peakAnnoEnrichment(
    seMarker = markerTest,
    ArchRProj = proj,
    peakAnnotation = "Motif",
    cutOff = "FDR <= 0.1 & Log2FC <= -0.5"
  )

# create a dataframe for plotting
df <- data.frame(TF = rownames(motifsDo), mlog10Padj = assay(motifsDo)[,1])
df <- df %>% arrange(desc(mlog10Padj))
df$rank <- seq_len(nrow(df))
df %>% head %>% knitr::kable()
```

```{r}
ggDo <- ggplot(df, aes(rank, mlog10Padj, color = mlog10Padj)) + 
  geom_point(size = 1) +
  ggrepel::geom_label_repel(
        data = df[rev(seq_len(30)), ], aes(x = rank, y = mlog10Padj, label = TF), 
        size = 1.5,
        nudge_x = 2,
        color = "black"
  ) + theme_ArchR() + 
  ylab("-log10(FDR) Motif Enrichment") +
  xlab("Rank Sorted TFs Enriched") +
  scale_color_gradientn(colors = paletteContinuous(set = "comet"))

ggDo
```


## Motif Enrichment in Marker Peaks

We can also perform motif enrichment on marker peaks. 

```{r}
# get marker peaks
markersPeaks <- getMarkerFeatures(
    ArchRProj = proj, 
    useMatrix = "PeakMatrix", 
    groupBy = "Clusters2",
  bias = c("TSSEnrichment", "log10(nFrags)"),
  testMethod = "wilcoxon"
)

# get enriched motifs
enrichMotifs <- peakAnnoEnrichment(
  seMarker = markersPeaks, # summarized exeriment object
  ArchRProj = proj,
  peakAnnotation = "Motif", # peak annotation object used for the hypergeometric testing
  cutOff = "FDR <= 0.01 & Log2FC >= 0.5"
)

enrichMotifs
```

The motif enrichments across all cell groups can be plotted in a heatmap. We will
limit the total number of motifs shown per cell type to seven. 

```{r, fig.width=10}
heatmapEM <- plotEnrichHeatmap(enrichMotifs, n = 7, transpose = TRUE)
ComplexHeatmap::draw(heatmapEM)
```



# ChromVAR Deviations Enrichment with ArchR

TF motif enrichments can help us predict which regulatory factors are most 
active in a specific cell type. The enrichments do not take into account 
the insertion sequence bias of the Tn5 transposase and they are not calculated on a per-cell basis.

With ChromVAR we can predict TF enrichment per cell from sparse chromatin 
accessibility data. ChromVAR uses a lot of memory and runtime. In ArchR implements
the same chromVAR analysis workflow by analyzing sample sub-matrices independently.


**Input**

* aligned sequencing reads
* chromatin accessibility peaks (aggregate across single cells)
* motif PWM (from cisBP)

**How it works**

For a motif and cell 
1. compute the raw accessibility deviation = number of fragments mapping to 
peaks with the motif - the average number of fragments across cells.
2.  since the aggregation across 

**Outputs**

1. **deviations:** A bias corrected measurement on how much the per-cell accessibility
of a given motif differs from the expected accessibility based on average of
all cells
2. **z-score:** for each bias-corrected deviation across all cells. The deviation
score is correlated with the per-cell read depth. A higher read depth means that 
you can have more confidence that a motif is actually enriched and that the deivation
is not occuring by chance.

First, a group of Background peaks needs to be chose. ChromVAR samples peaks based
on similarity in GC-content and number of fragments across all samples using the 
Mahalonobis distance. Afterwards, we are ready to compute per-cell deviations 
across all motif annotations. 

Per-cell motif activity. Find differentially active motifs between cell types.

```{r}
# get background peaks
proj <- addBgdPeaks(proj)

# compute per-cell deviations across all motif annotations
# the deviation matrix will be motif x cell, containing information
# whether there is a gain or loss in activity of the motif
proj <- addDeviationsMatrix(
  ArchRProj = proj,
  peakAnnotation = "Motif",
  force = TRUE
)

# the MotifMatrix is now saved in our ArchRProject
getAvailableMatrices(proj)
```

Below you can have a look at the deviations and a plot of deviations. The seqnames 
are not chromosomes, but instead this column contains `deviations` and `z`. The 
matrix stored as `MotifMatrix` is a sparse amtrix. For further analysis you might
have to subset the matrix based on the seqnames. 

```{r, results = "asis"}
# have  a look at the dataframe
# the variability of the deviation will be ranked and the top variable anntoations
# will be labelled
getVarDeviations(proj, name = "MotifMatrix", plot = FALSE) %>%
  head %>% knitr::kable()

# plot the deviations
plotVarDev <- getVarDeviations(proj, name = "MotifMatrix", plot = TRUE, n = 10)
plotVarDev
```



For downstream analysis you might want to extract a subset of motifs. To do this we use the `getFeatures()` function. This way you will get the names of 
the features you are interested in. We can then plot the distribution 
of ChromVAR deviation scores for each cluster. We use the impute weights to 
smooth the signal across nearby cells. 

```{r}
# these are the features we want to extract
motifs <- c("GATA1", "CEBPA", "EBF1", "IRF4", "TBX21", "PAX5")

#save the deviation matrix for the marker motifs
markerMotifs <- getFeatures(ArchRProj = proj, useMatrix = "MotifMatrix",
                            select = paste(motifs, collapse = "|"))
markerMotifs

```

```{r}
markerMotifs <- grep("z", markerMotifs, value = TRUE)
markerMotifs
markerMotifs <- markerMotifs[markerMotifs %ni% "z:SREBF1_22"]
markerMotifs
```

```#{r}
proj <- addImputeWeights(proj)
# the plot groups function groups, summarizes and plots data from
# ArcR project for visual comparison
p <- plotGroups(ArchRProj = proj, 
                groupBy = "Clusters2",
                colorBy = "MotifMatrix", 
                name = markerMotifs, # if colorBy is Motif Matrix
                # then this refers to motif names in the 
                imputeWeights = getImputeWeights(proj))
```




```{r}
proj <- addImputeWeights(proj)

p <- plotEmbedding(
    ArchRProj = proj, 
    colorBy = "MotifMatrix", 
    name = sort(markerMotifs), 
    embedding = "UMAP",
    imputeWeights = getImputeWeights(proj)
)

p1 <- lapply(p, function(x){
    x + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6.5) +
    theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
    theme(
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank()
    )
})
#do.call(cowplot::plot_grid, c(list(ncol = 3),p1))
```




```{r}
markerRNA <- getFeatures(ArchRProj = proj, useMatrix = "GeneScoreMatrix",
                         select = paste(motifs, collapse = "|"))

markerRNA <- markerRNA[markerRNA %ni% c("SREBF1","CEBPA-DT")]

markerRNA


p <- plotEmbedding(
    ArchRProj = proj, 
    colorBy = "GeneScoreMatrix", 
    name = sort(markerRNA), 
    embedding = "UMAP",
    imputeWeights = getImputeWeights(proj)
)

p2 <- lapply(p, function(x){
    x + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6.5) +
    theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
    theme(
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank()
    )
})
#do.call(cowplot::plot_grid, c(list(ncol = 3),p2))
```

In the plot below you can see the TF deviation z-scores. How do these deviation
z-scores compare to the inferred gene expression from gene scores of the same
TFs genes? From the integration of scATAC-seq data with scRNA-seq data we can also plot the gene expression for each of the TFs.


```{r, fig.height = 15, fig.width=10}
markerRNA <- getFeatures(proj, select = paste(motifs, collapse="|"),
                         useMatrix = "GeneIntegrationMatrix")
markerRNA <- markerRNA[markerRNA %ni% c("SREBF1","CEBPA-DT")]
markerRNA

p <- plotEmbedding(
    ArchRProj = proj, 
    colorBy = "GeneIntegrationMatrix", 
    name = sort(markerRNA), 
    embedding = "UMAP",
    continuousSet = "blueYellow",
    imputeWeights = getImputeWeights(proj)
)


p3 <- lapply(p, function(x){
    x + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6.5) +
    theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
    theme(
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank()
    )
})
do.call(cowplot::plot_grid, c(list(ncol = 3),p1, p2, p3))
```

```{r}
saveArchRProject(proj, outputDirectory = "Save_Vignette_object_4", 
                 load = FALSE)

```



# Footprinting

At a particular locus we want to predict the precise binding location of a 
TF. DNA bases whcih are bound by a TF are actually protected from the Tn5
transposase, but the bases next to the binding site are accessible. In the best case you would look at a particular region and determine binding location of 
a TF. But the sequencing depth is not high enough for this. Therefore, we
can take all peaks with for example a CTCF motif and make an aggregate TF 
footprint for CTCF across the entire genome. 

ArchR searches the peak regions for any sequence matching the TF bindign 
motif. These motif annotations are added to the project as a binary matrix motifs x peaks (0 = motif not present, 1 = motif present). If we have motif 
anntoations footprinting can be performed. The GenomicRanges object which is
the input to the `getFootrpints()` function contains the position information 
of the motifs. The function accounts for Tn5 insertion sequence bias. 


```{r}
# we create a GRangesList object where each TF motif  is represented
# by a separate GRanges object
motifPosition <- getPositions(proj)
print(motifPosition$TFAP2B_1)
```

We are only  intrested in a few TFs which we extract from the GRangesList. 

```{r}
motifs <- c("GATA1", "CEBPA", "EBF1", "IRF4", "TBX21", "PAX5")
markerMotifs <- unlist(lapply(motifs, function(x) 
  grep(x, names(motifPosition), value = TRUE)))
markerMotifs <- markerMotifs[markerMotifs %ni% "SREBF1_22"]
print(markerMotifs)
```

The actual footprinting will be performed on pseudo-bulks which we have created previously. 

```{r}
seFoot <- getFootprints(
  ArchRProj = proj, 
  positions = motifPosition[markerMotifs], # only use a subset of TFs
  # motifPositions is the GRangesList object and markerMotifs is the list of Tfs
  groupBy = "Clusters2"
)
```

## Normalization of footprints for Tn5 bias

The k-mer (default length = 6) sequences around the insertion site are identified. 
For each pseudo-bulk the single-base insertion sites are identified. Then these
1bp sites are expaned to k-bp windows (-k/2 and +k/2-1 bp from the insertion). 
A k-mer frequency table is created using the `oligonucleotidefrequency(w=k, simplify.as="collapse")` fuction. With the same function the expected k-mers
are calculated genome-wide using the BSgenome-associated genome file. 

```{r}
plotFootprints(
  seFoot = seFoot,
  ArchRProj = proj, 
  normMethod = "Subtract",
  plotName = "Footprints-Subtract-Bias",
  addDOC = FALSE,
  smoothWindow = 5, 
  plot = TRUE
)
```



## Feature Footprints

For example you can create a TSS insertion file. Footprinting is done on 
group coverage files derived from pseuo-bulk replicates. TSS insertion profiles
can be created without correction for Tn5 bias. 

Here we extend the footprints to 2000 bp flanks. 
```{r}
# add group coverage if you haven't done it before
#proj <- addGroupCoverages(ArchRProj = proj, groupBy = "Clusters2")



seTSS <- getFootprints(
  ArchRProj = proj, 
  positions = GRangesList(TSS = getTSS(proj)), 
  groupBy = "Clusters2",
  flank = 2000
)

plotFootprints(
  seFoot = seTSS,
  ArchRProj = proj, 
  normMethod = "None",
  plotName = "TSS-No-Normalization",
  addDOC = FALSE,
  flank = 2000,
  flankNorm = 100
)
```

```
saveArchRProject(proj, outputDirectory = "Save_Vignette_object_5/", load = FALSE)

```

