---
title: "Cicero co-accessibility of mouse gastrulation"
output: 
  html_document:
    toc: true
    toc_depth: 5
    code_folding: hide
    toc_float: true
    code_download: true
    theme: cosmo
    highlight: textmate
---

<style>
body {
text-align: justify}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = TRUE, autodep = TRUE, 
                      collapse = TRUE, message = FALSE)
knitr::opts_knit$set(root.dir = "/omics/groups/OE0533/internal/katharina/scDoRI/gastrulation_data/")
setwd("/omics/groups/OE0533/internal/katharina/scDoRI/gastrulation_data/")

set.seed(1)
```

```{r}
library(reticulate)
library(zellkonverter)
library(tidyverse)
library(cicero)
```

https://cole-trapnell-lab.github.io/cicero-release/docs/

The input data to cicero is a three column dataframe, with the peak coordinates,
the cell name and the number of reads from taht cell overlapping that peak, which 
is binarized. This represents the accessibility matrix A. 

```{r}
temp <- textConnection(readLines(gzcon(url("http://staff.washington.edu/hpliner/data/kidney_data.txt.gz"))))

# read in the data
cicero_data <- read.table(temp)
cicero_data %>% head

input_cds <- make_atac_cds(cicero_data, binarize = TRUE)
input_cds

```


```{r}
# 
input_cds <- detectGenes(input_cds)
input_cds <- estimateSizeFactors(input_cds)
input_cds <- reduceDimension(input_cds, max_components = 2, num_dim=6,
                      reduction_method = 'tSNE', norm_method = "none")
```

Before computing the co-accessibility, cells are aggregated based on similarity.

```{r}
tsne_coords <- t(reducedDimA(input_cds))
row.names(tsne_coords) <- row.names(pData(input_cds))

# in this object we have cellaggregates instaead of cells as in input_cds
cicero_cds <- make_cicero_cds(input_cds, reduced_coordinates = tsne_coords)
cicero_cds
```

Then we can compute the co-accessibility between peaks.
```{r}
data("human.hg19.genome")
sample_genome <- subset(human.hg19.genome, V1 == "chr18")
conns <- run_cicero(cicero_cds, sample_genome) # Takes a few minutes to run
head(conns)
```



# Gene activity scores

```{r}
temp <- tempfile()
download.file("ftp://ftp.ensembl.org/pub/release-65/gtf/mus_musculus/Mus_musculus.NCBIM37.65.gtf.gz", temp)
gene_anno <- rtracklayer::readGFF(temp)
unlink(temp)
```

```{r}
# rename some columns to match requirements
gene_anno$chromosome <- paste0("chr", gene_anno$seqid)
gene_anno$gene <- gene_anno$gene_id
gene_anno$transcript <- gene_anno$transcript_id
gene_anno$symbol <- gene_anno$gene_name

gene_anno %>% head
```


### How to know whether a peak is a promoter

From the gene annotations we have we can create a gene annotation set that marks the TSS
of thegenes. The TSS can be used as a proxy for promoters. For this we will 
extract the first exon of each transcript.


Why do we only subset for the positive strand?

```{r}
# get only the + strand
pos <- subset(gene_anno, strand == "+")
print(paste0("Number of + strand gene anntoations: ", dim(pos)[1]))

pos <- pos[order(pos$start), ]
pos %>% head

# now we want to remove all exons, but the first
# duplicate remoces all elements of a vector which are duplicates of elements
# with a smaller subscript -> returns a logical vector which elements
# are duplicates of elements with a smaller subscript
pos <- pos[!duplicated(pos$transcript), ]

print(paste0("Number of first exons on + strand ", dim(pos)[1]))

# create 1bp marker of the TSS
pos$end  <- pos$start + 1




# the same procedure for the negative strand
neg <- subset(gene_anno, strand == "-")
print(paste0("Number of- strand gene annotations: ", dim(neg)[1]))

neg <- neg[order(neg$start, decreasing = TRUE), ]

neg <- neg[!duplicated(neg$transcript),]
print(paste0("Number of first exons on minus strand: ", dim(neg)[1]))

neg$start <- neg$end -1


promoter_anno <- rbind(pos, neg)

# for our purposes we only need chromosome, coordinates and gene name
promoter_anno <- promoter_anno[, c("chromosome", "start", "end", "symbol")]
names(promoter_anno)[4] <- "gene"


promoter_anno %>% head
```


To be able to add gene promoter annotations to the cds file we need a dataframe
with chromosomes, start and end in the first three columns. The remaining columns
will be added to the fData table as feature data. 

The column gene contains the information whether a peak corresponds to a promoter
or not. If not, the entry is NA. 

```{r}
print("Feature data before:")
fData(input_cds) %>% head

input_cds <- annotate_cds_by_site(input_cds, promoter_anno)
print("Feature data after adding promoter annotations:")
fData(input_cds) %>% tail
```


Now we are ready  to compute gene activity scores. The input to the Cicero
function are the cds and the coaccessibility.

```{r}
# first we compute the unnormalized gene activity matrix
unnorm_ga <- build_gene_activity_matrix(input_cds, conns)
```
```{r}
unnorm_ga[1:5, 1:5]
```


## How are gene activity scores computed?

Lets have a look at the peak accessibility matrix?

```{r}
exprs(input_cds)[1:5, 1:5]
```

```{r}
accessibility_matrix <- exprs(input_cds)
promoter_peak_table <- fData(input_cds)
promoter_peak_table$peak <- as.character(row.names(promoter_peak_table))

# we select only genes where the entry is not NA. This way we can extract
# only the peaks which correspond to a promoter
promoter_peak_table <- promoter_peak_table[!is.na(promoter_peak_table$gene), ]

# extract only peak and gene columns, this way we know for each peak for which
# gene it is the promoter
promoter_peak_table <- promoter_peak_table[, c("peak", "gene")]
```


Next we can create site weights if we want to:

```#{r}
# Make site_weight matrix
site_names <- names(site_weights)
site_weights <- as(Matrix::Diagonal(x=as.numeric(site_weights)),
                  "sparseMatrix")
row.names(site_weights) <- site_names
colnames(site_weights) <- site_names
```


From the cicero connection table (output of `run_cicero()`) we can now 
compute distances between cicero peaks. 

```#{r}
"(?<=:)[^:]+"

str_remove(conns[1,1], "(?<=_)[^[0-9]]")
str_remove(conns[1,1], "_[0-9]*_[0-9]*")
str_extract(conns[1,1], "(?<=_)([^_]+)")
str_extract(conns[1,1], "([0-9]?!_)(^[0-9]+)")
str_remove(conns[1,1], ".*_")
```


```{r}

dist_conns <- conns %>% 
  separate(Peak1, c("chr_peak1", "start_peak1", "end_peak1"), sep = "_", remove = FALSE) %>% 
  separate(Peak2, c("chr_peak2", "start_peak2", "end_peak2"), sep = "_", remove = FALSE) %>%
  # get the middle bp for peak1
  mutate(peak1bp = round((as.integer(start_peak1) + as.integer(end_peak1))/2)) %>% 
  # get the middle bp for peak2
  mutate(peak2bp = round((as.integer(start_peak2) + as.integer(end_peak2))/2)) %>% 
  # add a column for the absolute distance in bp between all peaks
  mutate(distance = abs(peak2bp - peak1bp))

dist_conns %>% head

```

```{r}
```

For now we will use a distance threshold of 250,000 and a coaccessibility cutoff
of 0.25:

We will extract only the peaks that correspond to promoters, but
we also include the distal sites linked to them. 

```{r}
nonneg_cons <- dist_conns%>%
  filter((Peak1 %in% promoter_peak_table$peak | Peak2 %in% promoter_peak_table$peak) &
  coaccess >= .25 & 
  distance < 250000)

nonneg_cons <- nonneg_cons %>% select(Peak1, Peak2, coaccess)


dist_prox_conn <- rbind(nonneg_cons, data.frame(Peak1 = unique(promoter_peak_table$peak),
                              Peak2 = unique(promoter_peak_table$peak),
                              coaccess = 0))
dist_prox_conn$RowIndex <- match(dist_prox_conn$Peak1, unique(dist_prox_conn$Peak1))
dist_prox_conn$ColIndex <- match(dist_prox_conn$Peak2, unique(dist_prox_conn$Peak2))

# make a square matrix of connections from distal to proximal sites
distal_connectivity_matrix <- sparseMatrix(i = dist_prox_conn$RowIndex, 
                                           j = dist_prox_conn$ColIndex,
                                           x = dist_prox_conn$coaccess,
                                           dims = c(length(unique(dist_prox_conn$Peak1)), 
                                                    length(unique(dist_prox_conn$Peak2))),
                                          dimnames = list(unique(dist_prox_conn$Peak1),
                                                          unique(dist_prox_conn$Peak2)))


# Make a connectivity matrix of promoters vs all
promoter_conn_matrix <- distal_connectivity_matrix[unique(promoter_peak_table$peak),]

```





Have a look at the cicero function source code here: https://rdrr.io/github/cole-trapnell-lab/cicero-release/src/R/activityScores.R


```#{r, results = "asis"}
rownames(atac_overlap) %>% head

assays(atac_overlap)[[1]][1:5, 1:5]

matrix <- assays(atac_overlap)[[1]]

# convert the sparse matrix to a dataframe
# get a summary of the sparse matrix
sm <- summary(matrix)

# i is the row index, j is the column index and x is the value in the corresponding
# row and column combination
sm %>% head
# get the corresponding row names from the matrix
rows <- rownames(matrix)[sm[, 1]]

# get the corresponding column names from the matrix
cols <- colnames(matrix)[sm[, 2]]

# combine values, rownames and column names to dataframe
input_df <- data.frame(peak = rows, cell = cols, reads = sm[,3])

input_df %>% head %>% knitr::kable(caption = "input to Cicero")
```

```{r}
#input_cds <- make_atac_cds(input_df, binarize = TRUE)
```




```{r}
build_gene_activity_matrix <- function(input_cds,
                                       cicero_cons_info,
                                       site_weights=NULL,
                                       dist_thresh=250000,
                                       coaccess_cutoff=0.25){
    assertthat::assert_that(is(input_cds, "CellDataSet"))
    assertthat::assert_that(is.data.frame(cicero_cons_info))
    assertthat::assert_that(assertthat::has_name(cicero_cons_info, "Peak1"),
                            assertthat::has_name(cicero_cons_info, "Peak2"),
                            assertthat::has_name(cicero_cons_info, "coaccess"))

    assertthat::assert_that(assertthat::has_name(fData(input_cds), "gene"),
                            msg = paste("The fData table of the input CDS must",
                                        "have a column called 'gene'. See",
                                        "documentation for details.",
                                        collapse=" "))

    accessibility_mat <- exprs(input_cds)
    if (is.null(site_weights)) {
        site_weights <- Matrix::rowMeans(accessibility_mat) /
                       Matrix::rowMeans(accessibility_mat)
        site_weights[names(site_weights)] <- 1
    }

    gene_promoter_activity <-
        build_composite_gene_activity_matrix(input_cds,
                                             site_weights,
                                             cicero_cons_info,
                                             dist_thresh=dist_thresh,
                                             coaccess_cutoff=coaccess_cutoff)


    gene_activity_scores <- gene_promoter_activity

    return(gene_activity_scores)
}

build_composite_gene_activity_matrix <- function(input_cds,
                                                 site_weights,
                                                 cicero_cons_info,
                                                 dist_thresh=250000,
                                                 coaccess_cutoff=0.25) {
    accessibility_mat <- exprs(input_cds)
    promoter_peak_table <- fData(input_cds)
    promoter_peak_table$peak <- as.character(row.names(promoter_peak_table))
    promoter_peak_table <-
        promoter_peak_table[!is.na(promoter_peak_table$gene),]
    promoter_peak_table <- promoter_peak_table[,c("peak", "gene")]
    promoter_peak_table$gene <- as.character(promoter_peak_table$gene)

    # Make site_weight matrix
    site_names <- names(site_weights)
    site_weights <- as(Matrix::Diagonal(x=as.numeric(site_weights)),
                      "sparseMatrix")
    row.names(site_weights) <- site_names
    colnames(site_weights) <- site_names

    # Find distance between cicero peaks. If distance already calculated, skip
    if ("dist" %in% colnames(cicero_cons_info) == FALSE) {
        Peak1_cols <- split_peak_names(cicero_cons_info$Peak1)
        Peak2_cols <- split_peak_names(cicero_cons_info$Peak2)
        Peak1_bp <- round((as.integer(Peak1_cols[,3]) +
                          as.integer(Peak1_cols[,2])) / 2)
        Peak2_bp <- round((as.integer(Peak2_cols[,3]) +
                          as.integer(Peak2_cols[,2])) / 2)
        cicero_cons_info$dist <- abs(Peak2_bp - Peak1_bp)
    }

    # Get connections between promoters and distal sites above coaccess
    # threshold
    nonneg_cons <-
        cicero_cons_info[(cicero_cons_info$Peak1 %in%
                          promoter_peak_table$peak |
                          cicero_cons_info$Peak2 %in%
                          promoter_peak_table$peak) &
                          cicero_cons_info$coaccess >= coaccess_cutoff &
                          cicero_cons_info$dist < dist_thresh,]
    nonneg_cons <- nonneg_cons[,c("Peak1", "Peak2", "coaccess")]
    nonneg_cons <- nonneg_cons[!duplicated(nonneg_cons),]

    nonneg_cons$Peak1 <- as.character(nonneg_cons$Peak1)
    nonneg_cons$Peak2 <- as.character(nonneg_cons$Peak2)

    nonneg_cons <- rbind(nonneg_cons,
                        data.frame(Peak1=unique(promoter_peak_table$peak),
                                   Peak2=unique(promoter_peak_table$peak),
                                   coaccess=0))

    # Make square matrix of connections from distal to proximal
    distal_connectivity_matrix <- make_sparse_matrix(nonneg_cons,
                                                    x.name="coaccess")

    # Make connectivity matrix of promoters versus all
    promoter_conn_matrix <-
        distal_connectivity_matrix[unique(promoter_peak_table$peak),]

    # Get list of promoter and distal sites in accessibility mat
    promoter_safe_sites <- intersect(rownames(promoter_conn_matrix),
                                     row.names(accessibility_mat))
    distal_safe_sites <- intersect(colnames(promoter_conn_matrix),
                                     row.names(accessibility_mat))
    distal_safe_sites <- setdiff(distal_safe_sites, promoter_safe_sites)

    # Get accessibility info for promoters
    promoter_access_mat_in_cicero_map <- accessibility_mat[promoter_safe_sites,, drop=FALSE]

    # Get accessibility for distal sites
    distal_activity_scores <- accessibility_mat[distal_safe_sites,, drop=FALSE]

    # Scale connectivity matrix by site_weights
    scaled_site_weights <- site_weights[distal_safe_sites,distal_safe_sites, drop=FALSE]
    total_linked_site_weights <- promoter_conn_matrix[,distal_safe_sites, drop=FALSE] %*%
        scaled_site_weights
    total_linked_site_weights <- 1/Matrix::rowSums(total_linked_site_weights,
                                                na.rm=TRUE)
    total_linked_site_weights[is.finite(total_linked_site_weights) == FALSE] <- 0
    total_linked_site_weights[is.na(total_linked_site_weights)] <- 0
    total_linked_site_weights[is.nan(total_linked_site_weights)] <- 0
    total_linked_site_weights <- Matrix::Diagonal(x=total_linked_site_weights)
    scaled_site_weights <- total_linked_site_weights %*%
        promoter_conn_matrix[,distal_safe_sites, drop=FALSE] %*%
        scaled_site_weights
    scaled_site_weights@x[scaled_site_weights@x > 1] <- 1

    # Multiply distal accessibility by site weights
    distal_activity_scores <- scaled_site_weights %*% distal_activity_scores

    distal_activity_scores <-
        distal_activity_scores[row.names(promoter_access_mat_in_cicero_map),, drop=FALSE]

    # Sum distal and promoter scores
    promoter_activity_scores <- distal_activity_scores +
        promoter_access_mat_in_cicero_map

    # Make and populate final matrix
    promoter_gene_mat <-
        Matrix::sparseMatrix(j=as.numeric(factor(promoter_peak_table$peak)),
                             i=as.numeric(factor(promoter_peak_table$gene)),
                             x=1)
    colnames(promoter_gene_mat) = levels(factor(promoter_peak_table$peak))
    row.names(promoter_gene_mat) = levels(factor(promoter_peak_table$gene))
    promoter_gene_mat <- promoter_gene_mat[,row.names(promoter_activity_scores)]
    gene_activity_scores <- promoter_gene_mat %*% promoter_activity_scores

    return(gene_activity_scores)
}
```

```{r}
site_weights = NULL
dist_thresh=250000
coaccess_cutoff=0.25
cicero_cons_info <- conns
site_weights= NULL

```

```{r}
accessibility_mat <- exprs(input_cds)
accessibility_mat[1:5, 1:5]
print(paste0("There are ", dim(accessibility_mat)[[1]], " peaks and ", dim(accessibility_mat)[[2]], " cells in the accessibility matrix"))

promoter_peak_table <- fData(input_cds)
promoter_peak_table$peak <- as.character(row.names(promoter_peak_table))
promoter_peak_table <-
    promoter_peak_table[!is.na(promoter_peak_table$gene),]
promoter_peak_table <- promoter_peak_table[,c("peak", "gene")]
promoter_peak_table$gene <- as.character(promoter_peak_table$gene)
promoter_peak_table %>% head

print(paste0("The promoter peak table contains peaks and gene names of ", dim(promoter_peak_table)[[1]]))

# Make site_weight matrix
site_names <- names(site_weights)
site_weights <- as(Matrix::Diagonal(x=as.numeric(site_weights)),
                  "sparseMatrix")
row.names(site_weights) <- site_names
colnames(site_weights) <- site_names

# Find distance between cicero peaks. If distance already calculated, skip
if ("dist" %in% colnames(cicero_cons_info) == FALSE) {
    Peak1_cols <- split_peak_names(cicero_cons_info$Peak1)
    Peak2_cols <- split_peak_names(cicero_cons_info$Peak2)
    Peak1_bp <- round((as.integer(Peak1_cols[,3]) +
                      as.integer(Peak1_cols[,2])) / 2)
    Peak2_bp <- round((as.integer(Peak2_cols[,3]) +
                      as.integer(Peak2_cols[,2])) / 2)
    cicero_cons_info$dist <- abs(Peak2_bp - Peak1_bp)
}



# Distances
cicero_cons_info <- cicero_cons_info %>% 
  separate(Peak1, c("chr_peak1", "start_peak1", "end_peak1"), sep = "_", remove = FALSE) %>% 
  separate(Peak2, c("chr_peak2", "start_peak2", "end_peak2"), sep = "_", remove = FALSE) %>%
  # get the middle bp for peak1
  mutate(peak1bp = round((as.integer(start_peak1) + as.integer(end_peak1))/2)) %>% 
  # get the middle bp for peak2
  mutate(peak2bp = round((as.integer(start_peak2) + as.integer(end_peak2))/2)) %>% 
  # add a column for the absolute distance in bp between all peaks
  mutate(distance = abs(peak2bp - peak1bp))


# Get connections between promoters and distal sites above coaccess
# threshold
nonneg_cons <- cicero_cons_info %>% filter((Peak1 %in%
                      promoter_peak_table$peak |
                      Peak2 %in%
                      promoter_peak_table$peak) &
                      coaccess >= coaccess_cutoff &
                      distance < dist_thresh)

nonneg_cons <- nonneg_cons[,c("Peak1", "Peak2", "coaccess")]
nonneg_cons <- nonneg_cons[!duplicated(nonneg_cons),]

nonneg_cons$Peak1 <- as.character(nonneg_cons$Peak1)
nonneg_cons$Peak2 <- as.character(nonneg_cons$Peak2)

nonneg_cons <- rbind(nonneg_cons,
                    data.frame(Peak1=unique(promoter_peak_table$peak),
                               Peak2=unique(promoter_peak_table$peak),
                               coaccess=0))




# Make square matrix of connections from distal to proximal
nonneg_cons$RowIndex <- match(nonneg_cons$Peak1, unique(nonneg_cons$Peak1))
nonneg_cons$ColIndex <- match(nonneg_cons$Peak2, unique(nonneg_cons$Peak2))

# make a square matrix of connections from distal to proximal sites
distal_connectivity_matrix <- sparseMatrix(i = nonneg_cons$RowIndex, 
                                           j = nonneg_cons$ColIndex,
                                           x = nonneg_cons$coaccess,
                                           dims = c(length(unique(nonneg_cons$Peak1)), 
                                                    length(unique(nonneg_cons$Peak2))),
                                          dimnames = list(unique(nonneg_cons$Peak1),
                                                          unique(nonneg_cons$Peak2)))
print(paste0("The connectivity matrix between distal and proximal sites contains ", dim(distal_connectivity_matrix)[[1]], " connections"))

#distal_connectivity_matrix <- make_sparse_matrix(nonneg_cons,
 #                                               x.name="coaccess")

# Make connectivity matrix of promoters versus all
promoter_conn_matrix <-
    distal_connectivity_matrix[unique(promoter_peak_table$peak),]
print(paste0("The promoter connectivity matrix contains connections between ", dim(promoter_conn_matrix)[[1]], " promoter regions and ", dim(promoter_conn_matrix)[[2]], " distal and promoter regions"))

# Get list of promoter and distal sites in accessibility mat
# In this case all promoters are found in the accessibility matrix
promoter_safe_sites <- intersect(rownames(promoter_conn_matrix),
                                 row.names(accessibility_mat))

# all distal sites are also found in the accessbility matrix. 
distal_safe_sites <- intersect(colnames(promoter_conn_matrix),
                                 row.names(accessibility_mat))
distal_safe_sites <- setdiff(distal_safe_sites, promoter_safe_sites)

print(paste0("There are ", length(distal_safe_sites), " distal sites and ", length(promoter_safe_sites), " promoter sites."))
```

Now we have a list of promoters and their coaccessibility with distal sites and
a list of distal sites. Now we want to get the accessibility information for the
promoters. 

```{r}
# Get accessibility info for promoters
# we get a accessbiility matrix with the same number of rows as number of promoters 
# identified above
promoter_access_mat_in_cicero_map <- accessibility_mat[promoter_safe_sites,, drop=FALSE]

# we can do the same thing for the distal sites
# Get accessibility for distal sites
distal_activity_scores <- accessibility_mat[distal_safe_sites,, drop=FALSE]
```

```{r}
# Scale connectivity matrix by site_weights
scaled_site_weights <- site_weights[distal_safe_sites,distal_safe_sites, drop=FALSE]
total_linked_site_weights <- promoter_conn_matrix[,distal_safe_sites, drop=FALSE] %*%
    scaled_site_weights
total_linked_site_weights <- 1/Matrix::rowSums(total_linked_site_weights,
                                            na.rm=TRUE)
total_linked_site_weights[is.finite(total_linked_site_weights) == FALSE] <- 0
total_linked_site_weights[is.na(total_linked_site_weights)] <- 0
total_linked_site_weights[is.nan(total_linked_site_weights)] <- 0
total_linked_site_weights <- Matrix::Diagonal(x=total_linked_site_weights)
scaled_site_weights <- total_linked_site_weights %*%
    promoter_conn_matrix[,distal_safe_sites, drop=FALSE] %*%
    scaled_site_weights
scaled_site_weights@x[scaled_site_weights@x > 1] <- 1


# Multiply distal accessibility by site weights
distal_activity_scores <- scaled_site_weights %*% distal_activity_scores

distal_activity_scores <-
    distal_activity_scores[row.names(promoter_access_mat_in_cicero_map),, drop=FALSE]

```


Not really sure how this works...

```#{r}

# Sum distal and promoter scores
promoter_activity_scores <- distal_activity_scores +
    promoter_access_mat_in_cicero_map
```

Based on the promoter peak table which is shown below, we can create a 

```{r}
promoter_peak_table %>% head
```


```{r}

# Make and populate final matrix
promoter_gene_mat <-
    Matrix::sparseMatrix(j=as.numeric(factor(promoter_peak_table$peak)),
                         i=as.numeric(factor(promoter_peak_table$gene)),
                         x=1)
colnames(promoter_gene_mat) = levels(factor(promoter_peak_table$peak))
row.names(promoter_gene_mat) = levels(factor(promoter_peak_table$gene))
promoter_gene_mat <- promoter_gene_mat[,row.names(promoter_activity_scores)]

promoter_gene_mat[1:5, 1:5]

# This is now a gene x promoter and promoter x cells mutliplication giving
# giving us a gene x cell matrix
#gene_activity_scores <- promoter_gene_mat %*% promoter_activity_scores
gene_activity_scores <- promoter_gene_mat %*% promoter_access_mat_in_cicero_map
gene_activity_scores[1:5, 1:5]
```



